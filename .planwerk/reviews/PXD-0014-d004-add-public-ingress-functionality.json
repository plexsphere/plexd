{
  "feature_id": "PXD-0014",
  "title": "D004: Add public ingress functionality",
  "date": "2026-02-12",
  "summary": "Implements public ingress for bridge mode: IngressManager with TCP proxy (passthrough and TLS terminate), IngressController interface, SSE event handlers (assign/revoke/config-updated), IngressReconcileHandler for convergence, API types (IngressConfig, IngressRule, IngressInfo), config validation, heartbeat/capability reporting, and comprehensive tests (unit, handler, integration with -race). Documentation added.",
  "verdict": "APPROVED",
  "tests_checklist": [
    {"item": "All tests pass (go test -race ./internal/bridge/... ./internal/api/...)", "checked": true},
    {"item": "Unit tests cover Setup, AddRule, RemoveRule, Teardown, IngressStatus, IngressCapabilities", "checked": true},
    {"item": "Edge cases covered: duplicate rule, max rules, non-existent remove, idempotent teardown, error aggregation", "checked": true},
    {"item": "TLS terminate mode tested: valid cert, invalid cert", "checked": true},
    {"item": "SSE handler tests: assign, revoke, config-updated, malformed payloads", "checked": true},
    {"item": "Reconcile handler tests: nil config, add new, remove stale, mixed add+remove", "checked": true},
    {"item": "Integration test: full lifecycle with real TCP proxy and echo server", "checked": true},
    {"item": "Integration test: reconcile drift with state transitions", "checked": true},
    {"item": "Integration test: concurrent SSE + reconcile with -race", "checked": true},
    {"item": "goleak.VerifyTestMain in leak_test.go covers goroutine leak detection", "checked": true},
    {"item": "API types round-trip JSON tests for IngressConfig, IngressRule, IngressInfo", "checked": true},
    {"item": "Config validation tests: ingress without bridge, invalid MaxIngressRules, invalid DialTimeout, disabled, valid", "checked": true}
  ],
  "code_quality_checklist": [
    {"item": "Follows existing bridge module patterns (interface-based controller, Manager with mu/active/tracked-state)", "checked": true},
    {"item": "SSE handlers follow factory function pattern (HandleIngressRuleAssigned, etc.)", "checked": true},
    {"item": "ReconcileHandler follows UserAccessReconcileHandler pattern", "checked": true},
    {"item": "Error prefixes follow 'bridge: ingress: <operation>: <detail>' pattern", "checked": true},
    {"item": "Structured logging with component=bridge", "checked": true},
    {"item": "Functions have clear single responsibility", "checked": true},
    {"item": "No dead code or commented-out code", "checked": true},
    {"item": "Mock follows compile-time interface check pattern (var _ IngressController = ...)", "checked": true}
  ],
  "security_checklist": [
    {"item": "TLS MinVersion set to tls.VersionTLS12", "checked": true},
    {"item": "CertPEM/KeyPEM not logged (only rule_id, listen_port, target, mode logged)", "checked": true},
    {"item": "Config validation rejects invalid configuration before runtime", "checked": true},
    {"item": "Dial timeout prevents indefinite connection hangs", "checked": true},
    {"item": "Context cancellation propagates to proxy goroutines", "checked": true},
    {"item": "No hardcoded secrets", "checked": true}
  ],
  "architecture_checklist": [
    {"item": "IngressController interface abstracts TCP operations for testability", "checked": true},
    {"item": "IngressManager follows established Manager pattern", "checked": true},
    {"item": "Clean separation: manager (ingress.go), handlers (ingress_handler.go), controller (ingress_controller.go)", "checked": true},
    {"item": "API types extend existing StateResponse and HeartbeatRequest", "checked": true},
    {"item": "Solution is as simple as possible for the requirements", "checked": true}
  ],
  "dry_yagni_checklist": [
    {"item": "No duplicated code", "checked": true},
    {"item": "No unnecessary abstractions", "checked": true},
    {"item": "No future-proofing beyond requirements", "checked": true}
  ],
  "fail_fast_checklist": [
    {"item": "Config validation fails early for invalid ingress settings", "checked": true},
    {"item": "TLS certificate parsing fails before listener creation", "checked": true},
    {"item": "Duplicate rule and max rules checked before listen", "checked": true}
  ],
  "defensive_checklist": [
    {"item": "Teardown aggregates errors and continues cleanup", "checked": true},
    {"item": "Teardown is idempotent", "checked": true},
    {"item": "RemoveRule for non-existent rule is a no-op", "checked": true},
    {"item": "Mutex protects concurrent access to activeRules", "checked": true},
    {"item": "Connection count tracked via atomic.Int64", "checked": true}
  ],
  "security_findings": [],
  "architecture_findings": [],
  "issues_found": [
    {
      "id": "Q-01",
      "severity": "minor",
      "check_id": "C2",
      "description": "IngressReconcileHandler does not detect changed rules (same RuleID, different TargetAddr/Mode/Port). Task 3.2 mentions 'restart changed' but the implementation only handles add/remove. However, this is consistent with UserAccessReconcileHandler which uses the same add/remove-only pattern. The control plane can work around this by revoking and re-assigning the rule with updated config.",
      "location": "internal/bridge/ingress_handler.go:69-111",
      "fix": "Optional: compare rule fields for existing IDs and remove+re-add changed rules. Consistent with existing codebase pattern so not blocking."
    },
    {
      "id": "Q-02",
      "severity": "minor",
      "check_id": "C3",
      "description": "AddRule does not guard against being called when the manager is inactive (m.active == false). If SSE events arrive before Setup or after Teardown, listeners and goroutines could be orphaned since Teardown checks m.active before cleanup.",
      "location": "internal/bridge/ingress.go:122",
      "fix": "Add early return with error when !m.active at the top of AddRule. Same pattern could benefit RemoveRule."
    },
    {
      "id": "Q-03",
      "severity": "minor",
      "check_id": "TE7",
      "description": "proxyConnection uses an unusual IIFE (immediately-invoked function expression) pattern in the select statement (lines 269-276) that creates a goroutine inside a case expression. While functionally correct, it reduces readability compared to spawning both copy goroutines before the select.",
      "location": "internal/bridge/ingress.go:269-276",
      "fix": "Suggestion only: refactor to spawn both io.Copy goroutines before the select with two named done channels for clarity."
    }
  ],
  "suggested_improvements": [
    "Add m.active guard to AddRule/RemoveRule to prevent orphaned listeners when called on inactive manager",
    "Consider detecting changed rules in reconcile (remove+re-add when same ID has different config), consistent with task 3.2 spec",
    "Simplify proxyConnection select by spawning both io.Copy goroutines before the select statement"
  ],
  "next_steps": [
    "Integrate IngressManager into the main bridge Manager wiring (Setup/Teardown lifecycle, SSE handler registration, reconcile handler registration)",
    "Add production IngressController implementation (actual TCP listener with optional TLS)",
    "Wire ingress capabilities into registration and heartbeat reporting"
  ]
}
