{
  "feature_id": "PXD-0023",
  "title": "Create CI workflow with lint, unit test, and integration test jobs",
  "slug": "create-ci-workflow-with-lint-unit-test-and",
  "status": "proposed",
  "phase": null,
  "summary": "",
  "description": "**Size:** ðŸ“¦ medium\n**Category:** infrastructure\n**Priority:** high\n**Source:** Proposed for 'In the current implementation and planning, no'\n\nCreate `.github/workflows/ci.yml` with three parallel jobs:\n\n**Lint job:**\n- `actions/checkout@v4` + `actions/setup-go@v5` with Go 1.24\n- `go mod verify` to validate dependency integrity\n- `go vet ./...` for static analysis\n- `staticcheck ./...` (install via `go install honnef.co/go/tools/cmd/staticcheck@latest`)\n- `golangci/golangci-lint-action@v6` with default config (no `.golangci.yml` needed)\n\n**Unit test job:**\n- `actions/checkout@v4` + `actions/setup-go@v5` with Go 1.24\n- `go test -race -count=1 ./...` â€” race detection enabled, cache disabled\n\n**Integration test job:**\n- `actions/checkout@v4` + `actions/setup-go@v5` with Go 1.24\n- `go test -race -count=1 -run Integration ./...` â€” only TestIntegration* functions\n\n**Trigger config:** `push` to `main` branch + all `pull_request` events.\n\nAll three jobs run in parallel on `ubuntu-latest`. `actions/setup-go@v5` handles Go module caching automatically via `go.sum`.\n\n**Rationale:** No CI pipeline exists in the project. Every PR and push to main currently has zero automated quality gates â€” no lint checks, no test verification, no race detection. This means broken code, lint violations, and race conditions can be merged silently. A CI pipeline is foundational infrastructure that blocks bad code before it reaches main, catches regressions immediately, and establishes quality expectations for all contributors.\n\n**Affected Areas:**\n- .github/workflows/ci.yml",
  "stories": [],
  "requirements": [],
  "tasks": [],
  "test_specifications": [],
  "affected_files": [],
  "similar_patterns": [],
  "review_criteria": [],
  "implementation_notes": "",
  "status_history": {
    "proposed": {
      "github_account": "berendt",
      "timestamp": "2026-02-12T21:45:42.102792"
    }
  },
  "elaboration": "\n\n**Size:** ðŸ”¨ medium\n**Category:** infrastructure\n**Priority:** high\n\n## Summary\n\nAdd a GitHub Actions CI pipeline (`.github/workflows/ci.yml`) to enforce code quality on every pull request and push to `main`. The pipeline runs three parallel jobs: linting (`go vet`, `staticcheck`, `golangci-lint`), unit tests with race detection, and integration tests. No release, deploy, or packaging workflows â€” those don't exist in the project yet.\n\n## Scope\n\n**Included:**\n- **Lint job** â€” `go mod verify` â†’ `go vet ./...` â†’ `staticcheck ./...` â†’ `golangci-lint run` (using `golangci/golangci-lint-action@v6`)\n- **Unit test job** â€” `go test -race -count=1 ./...` (excludes integration tests)\n- **Integration test job** â€” `go test -race -count=1 -run Integration ./...` (separate parallel job)\n- **Go module verification** â€” `go mod verify` to catch tampered dependencies\n- **Trigger configuration** â€” `push` to `main` + all `pull_request` events\n- **Go 1.24** â€” Pinned to match `go.mod`\n\n**Excluded (YAGNI):**\n- **Release/binary build workflows** â€” No release tooling, Dockerfile, or goreleaser config exists\n- **Docker image builds** â€” No Dockerfile in repo\n- **Deployment workflows** â€” No deploy target defined\n- **Code coverage reporting/badges** â€” Adds complexity without immediate value; layer on later\n- **Dependency update automation (Dependabot/Renovate)** â€” Separate concern, not quality gating\n- **`.golangci.yml` config file** â€” Separate feature; defaults are fine to start\n\n## Visualization\n\n```mermaid\nflowchart TD\n    trigger[\"Push to main / PR opened\"]\n    trigger --> lint[\"Job: Lint\"]\n    trigger --> unit[\"Job: Unit Tests\"]\n    trigger --> integ[\"Job: Integration Tests\"]\n\n    subgraph lint_steps[\"Lint Steps\"]\n        l1[\"setup-go v5 - Go 1.24\"] --> l2[\"go mod verify\"]\n        l2 --> l3[\"go vet ./...\"]\n        l3 --> l4[\"staticcheck ./...\"]\n        l4 --> l5[\"golangci-lint-action v6\"]\n    end\n\n    subgraph unit_steps[\"Unit Test Steps\"]\n        u1[\"setup-go v5 - Go 1.24\"] --> u2[\"go test -race -count=1 ./...\"]\n    end\n\n    subgraph integ_steps[\"Integration Test Steps\"]\n        i1[\"setup-go v5 - Go 1.24\"] --> i2[\"go test -race -count=1 -run Integration ./...\"]\n    end\n\n    lint --> lint_steps\n    unit --> unit_steps\n    integ --> integ_steps\n```\n\n```mermaid\nsequenceDiagram\n    participant D as Developer\n    participant GH as GitHub\n    participant CI as Actions Runner\n\n    D->>GH: Push / Open PR\n    GH->>CI: Trigger ci.yml\n    par Lint Job\n        CI->>CI: go mod verify\n        CI->>CI: go vet\n        CI->>CI: staticcheck\n        CI->>CI: golangci-lint\n    and Unit Test Job\n        CI->>CI: go test -race ./...\n    and Integration Test Job\n        CI->>CI: go test -race -run Integration ./...\n    end\n    CI-->>GH: Report status checks\n    GH-->>D: PR status updated\n```\n\n## Key Components\n\n- **`.github/workflows/ci.yml`** (new): Single workflow file with 3 parallel jobs\n- **Lint job**: `go mod verify` â†’ `go vet` â†’ `staticcheck` â†’ `golangci-lint` â€” uses `golangci/golangci-lint-action@v6` for correct version pinning and caching\n- **Unit test job**: `go test -race -count=1 ./...` â€” all packages, race detector enabled, no caching (`-count=1`)\n- **Integration test job**: `go test -race -count=1 -run Integration ./...` â€” only `TestIntegration*` tests, separated for independent failure tracking\n- **Go module cache**: `actions/setup-go@v5` handles module caching automatically via `go.sum`\n- **Trigger**: `push` to `main` + all `pull_request` events"
}